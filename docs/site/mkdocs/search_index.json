{
    "docs": [
        {
            "location": "/installation/", 
            "text": "Composer (recommended)\n#\n\n\nDoes require ProcessWire 2.8+\n\nRun the following command in the root of your project and install the module via the backend after that:\n\n\ncomposer require lostkobrakai/migrations\n\n\n\n\n\nAdding the module via composer has the benefit, that all dependencies (CLI) are automatically installed as well.\n\n\nIf you don't have composer installed, have a look here on how to get it: \nComposer Installation\n\n\nModules Directory\n#\n\n\n\n\nLog in to your ProcessWire admin and go to the Modules page.\n\n\nGo to the New tab and expand the Add Module From Directory section.\n\n\nEnter the Module Class Name: Migrations\n\n\nClick the Download and Install button.\n\n\n\n\nOther\n#\n\n\nIf those above do not work for you use one of the other methods explained here:\n\n\nHow-To Install or Uninstall Modules", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#composer-recommended", 
            "text": "Does require ProcessWire 2.8+ \nRun the following command in the root of your project and install the module via the backend after that:  composer require lostkobrakai/migrations  Adding the module via composer has the benefit, that all dependencies (CLI) are automatically installed as well.  If you don't have composer installed, have a look here on how to get it:  Composer Installation", 
            "title": "Composer (recommended)"
        }, 
        {
            "location": "/installation/#modules-directory", 
            "text": "Log in to your ProcessWire admin and go to the Modules page.  Go to the New tab and expand the Add Module From Directory section.  Enter the Module Class Name: Migrations  Click the Download and Install button.", 
            "title": "Modules Directory"
        }, 
        {
            "location": "/installation/#other", 
            "text": "If those above do not work for you use one of the other methods explained here:  How-To Install or Uninstall Modules", 
            "title": "Other"
        }, 
        {
            "location": "/", 
            "text": "___       ___       ___       ___       ___       ___       ___\n   /\\__\\     /\\  \\     /\\  \\     /\\  \\     /\\  \\     /\\  \\     /\\  \\\n  /::L_L_   _\\:\\  \\   /::\\  \\   /::\\  \\   /::\\  \\    \\:\\  \\   /::\\  \\\n /:/L:\\__\\ /\\/::\\__\\ /:/\\:\\__\\ /::\\:\\__\\ /::\\:\\__\\   /::\\__\\ /::\\:\\__\\\n \\/_/:/  / \\::/\\/__/ \\:\\:\\/__/ \\;:::/  / \\/\\::/  /  /:/\\/__/ \\:\\:\\/  /\n   /:/  /   \\:\\__\\    \\::/  /   |:\\/__/    /:/  /   \\/__/     \\:\\/  /\n   \\/__/     \\/__/     \\/__/     \\|__|     \\/__/               \\/__/\n\n\n\n\nIntro \n#\n\n\nMigrations is a module to manage migration files, which in themselves allow you to handle all the development steps, which affect the ProcessWire database, across multiple enviroments. Be it a simple local development and online live environment by a single developer or multiple developers working in a team with multiple server environments to go through before shipping.\n\n\nMigration files are simple small class files, which utilize the \nProcessWire API\n to run any database affecting changes. It's not as nice as using the Admin UI directly, but certainly better than trying to migrate changes manually \n possibly weeks after adding the changes. \n\n\nThey are NOT database migrations like you might know them from frameworks like Laravel or Ruby on Rails. Those files won't setup any database tables or change table column types. It's about recreating what normally would be done via the backend UI. Creating a field, removing a field from a template, installing a module and so on.\n\n\n\n\nMigration Types\n#\n\n\nThere are currently four types of migrations shipped with the module:\n\n\ndefault (Migration)\n#\n\n\nDefault migrations are the most free form migrations. There's just a description and two functions \u2013 \nupdate()\n and \ndowngrade()\n. What you're doing in those functions is totally up to you, but it's recommended to try the best to keep changes as reversible as possible. Meaning that running update() and downgrade() once should have as less effect on the installation as possible. The ProcessWire API is available exactly like in modules using the \n$this-\npages\n, \n$this-\nconfig\n, \u2026 syntax.\n\n\nCreate/Delete Migrations\n#\n\n\n\n\nFieldMigration\n\n\nTemplateMigration\n\n\nModuleMigration\n  \n\n\n\n\nThese make your live easier by providing a more declarative way of migrating the creation of Fields/Templates or the installation of modules. All the boilerplate is handled by the base classes these migrations do extend, so you don't need to think about \nupdate()\n and \ndowngrade()\n. You can rather just describe the item you want to be handled and the rest is been taken care of.\n\n\nCLI\n#\n\n\n\n\nInstall the module with composer to use the CLI\nIt will also install all the dependencies and symlink the script to the composer bin-dir. TL;DR it'll make things easier.\n\n\n\n\n\n\nThe module does include a CLI interface, which does allow migrations to be run automatically by Continous Integration Systems or deployment scripts or just by yourself if you like the command-line. I suggest adding 'vendor/bin' to your $PATH variable. Then you can simply call the CLI script by \nmigrate -h\n from your project root folder. Otherwise you'll need to call it like that: \n./vendor/migrate -h\n.\n\n\n\n> migrate -h\n\n[\u2026]\n\nUsage: migrate [-h, --help] [-i info, --info info] [-m migrate, --migrate migrate] [-n new, --new new] \n  [-nf newField, --newField newField] [-nm newModule, --newModule newModule] \n  [-nt newTemplate, --newTemplate newTemplate] [-r rollback, --rollback rollback]\n\nOptional Arguments:\n    -m migrate, --migrate migrate\n        Run a specific migration or all new* ones if none given.\n        * From latest migrated to newest.\n    -r rollback, --rollback rollback\n        Undo a specific migration or the latest one if none given.\n    -n new, --new new\n        Bootstrap a new migrations file. Optionally you can already supply a description.\n    -nt newTemplate, --newTemplate newTemplate\n        Bootstrap a new template migrations file. Optionally you can already supply a description.\n    -nm newModule, --newModule newModule\n        Bootstrap a new module migrations file. Optionally you can already supply a description.\n    -nf newField, --newField newField\n        Bootstrap a new field migrations file. Optionally you can already supply a description.\n    -i info, --info info\n        Get detailed info about a migration.\n    -h, --help\n        Show all commands of the cli tool.\n\n\n\n\nHelper Functions\n#\n\n\nThere are already a handful of helper function included in the Migration base class, which tackle things I found to need way to much boilerplate for kinda simple changes. Read the code comments on what each of them does.\n\n\n\n\nThe number of helper functions will probably grow over time.\n\n\n\n\n?php\n\n\n\n/**\n\n\n * This does use @diogo\ns while loop technique to loop over all pages \n\n\n * without getting memory exhaustion. \n\n\n */\n\n\n$this\n-\neachPageUncache\n(\ntemplate=toBeHidden\n,\n \nfunction\n(\n$p\n){\n\n  \n$p\n-\nsetAndSave\n(\nstatus\n,\n \nPage\n::\nstatusHidden\n);\n\n\n});\n \n\n\n\n\n\n?php\n\n\n\n/**\n\n\n * $template, $field, $reference = null, $after = true\n\n\n * The below function reads like this:\n\n\n * In the template \u2026 add the field \u2026 relative to the field \u2026 in the position after/before\n\n\n */\n\n\n$this\n-\ninsertIntoTemplate\n(\nbasic-page\n,\n \nimages\n,\n \nbody\n,\n \nfalse\n);\n \n\n\n\n\n\n?php\n\n\n\n/**\n\n\n * Edit field settings in context of a template\n\n\n */\n\n\n$this\n-\neditInTemplateContext\n(\nbasic-page\n,\n \ntitle\n,\n \nfunction\n(\n$f\n,\n \n$template\n){\n\n  \n$f\n-\nlabel\n \n=\n \nHeadline\n;\n\n\n});\n \n\n\n\n\n\nCustom Helper Functions\n#\n\n\nYou can create your own helper functions by using ProcessWire \nHooks\n. These functions can then be used in your migrations.\n\n\n?php\n\n\n\n// in ready.php\n\n\n$wire\n-\naddHook\n(\nMigration::renameHome\n,\n \nfunction\n(\nHookEvent\n \n$event\n){\n\n    \n$name\n \n=\n \n$event\n-\narguments\n(\n0\n);\n\n    \n$event\n-\nwire\n(\npages\n)\n-\nget\n(\n/\n)\n-\nsetAndSave\n(\ntitle\n,\n \n$name\n);\n\n\n});\n\n\n\n// in the migration::update method\n\n\n$this\n-\nrenameHome\n(\nRoot\n);\n \n\n// in the migration::downgrade method\n\n\n$this\n-\nrenameHome\n(\nHome\n);", 
            "title": "What is it"
        }, 
        {
            "location": "/#intro", 
            "text": "Migrations is a module to manage migration files, which in themselves allow you to handle all the development steps, which affect the ProcessWire database, across multiple enviroments. Be it a simple local development and online live environment by a single developer or multiple developers working in a team with multiple server environments to go through before shipping.  Migration files are simple small class files, which utilize the  ProcessWire API  to run any database affecting changes. It's not as nice as using the Admin UI directly, but certainly better than trying to migrate changes manually   possibly weeks after adding the changes.   They are NOT database migrations like you might know them from frameworks like Laravel or Ruby on Rails. Those files won't setup any database tables or change table column types. It's about recreating what normally would be done via the backend UI. Creating a field, removing a field from a template, installing a module and so on.", 
            "title": "Intro"
        }, 
        {
            "location": "/#migration-types", 
            "text": "There are currently four types of migrations shipped with the module:", 
            "title": "Migration Types"
        }, 
        {
            "location": "/#default-migration", 
            "text": "Default migrations are the most free form migrations. There's just a description and two functions \u2013  update()  and  downgrade() . What you're doing in those functions is totally up to you, but it's recommended to try the best to keep changes as reversible as possible. Meaning that running update() and downgrade() once should have as less effect on the installation as possible. The ProcessWire API is available exactly like in modules using the  $this- pages ,  $this- config , \u2026 syntax.", 
            "title": "default (Migration)"
        }, 
        {
            "location": "/#createdelete-migrations", 
            "text": "FieldMigration  TemplateMigration  ModuleMigration      These make your live easier by providing a more declarative way of migrating the creation of Fields/Templates or the installation of modules. All the boilerplate is handled by the base classes these migrations do extend, so you don't need to think about  update()  and  downgrade() . You can rather just describe the item you want to be handled and the rest is been taken care of.", 
            "title": "Create/Delete Migrations"
        }, 
        {
            "location": "/#cli", 
            "text": "Install the module with composer to use the CLI It will also install all the dependencies and symlink the script to the composer bin-dir. TL;DR it'll make things easier.    The module does include a CLI interface, which does allow migrations to be run automatically by Continous Integration Systems or deployment scripts or just by yourself if you like the command-line. I suggest adding 'vendor/bin' to your $PATH variable. Then you can simply call the CLI script by  migrate -h  from your project root folder. Otherwise you'll need to call it like that:  ./vendor/migrate -h .  \n> migrate -h\n\n[\u2026]\n\nUsage: migrate [-h, --help] [-i info, --info info] [-m migrate, --migrate migrate] [-n new, --new new] \n  [-nf newField, --newField newField] [-nm newModule, --newModule newModule] \n  [-nt newTemplate, --newTemplate newTemplate] [-r rollback, --rollback rollback]\n\nOptional Arguments:\n    -m migrate, --migrate migrate\n        Run a specific migration or all new* ones if none given.\n        * From latest migrated to newest.\n    -r rollback, --rollback rollback\n        Undo a specific migration or the latest one if none given.\n    -n new, --new new\n        Bootstrap a new migrations file. Optionally you can already supply a description.\n    -nt newTemplate, --newTemplate newTemplate\n        Bootstrap a new template migrations file. Optionally you can already supply a description.\n    -nm newModule, --newModule newModule\n        Bootstrap a new module migrations file. Optionally you can already supply a description.\n    -nf newField, --newField newField\n        Bootstrap a new field migrations file. Optionally you can already supply a description.\n    -i info, --info info\n        Get detailed info about a migration.\n    -h, --help\n        Show all commands of the cli tool.", 
            "title": "CLI"
        }, 
        {
            "location": "/#helper-functions", 
            "text": "There are already a handful of helper function included in the Migration base class, which tackle things I found to need way to much boilerplate for kinda simple changes. Read the code comments on what each of them does.   The number of helper functions will probably grow over time.   ?php  /**   * This does use @diogo s while loop technique to loop over all pages    * without getting memory exhaustion.    */  $this - eachPageUncache ( template=toBeHidden ,   function ( $p ){ \n   $p - setAndSave ( status ,   Page :: statusHidden );  });    ?php  /**   * $template, $field, $reference = null, $after = true   * The below function reads like this:   * In the template \u2026 add the field \u2026 relative to the field \u2026 in the position after/before   */  $this - insertIntoTemplate ( basic-page ,   images ,   body ,   false );    ?php  /**   * Edit field settings in context of a template   */  $this - editInTemplateContext ( basic-page ,   title ,   function ( $f ,   $template ){ \n   $f - label   =   Headline ;  });", 
            "title": "Helper Functions"
        }, 
        {
            "location": "/#custom-helper-functions", 
            "text": "You can create your own helper functions by using ProcessWire  Hooks . These functions can then be used in your migrations.  ?php  // in ready.php  $wire - addHook ( Migration::renameHome ,   function ( HookEvent   $event ){ \n     $name   =   $event - arguments ( 0 ); \n     $event - wire ( pages ) - get ( / ) - setAndSave ( title ,   $name );  });  // in the migration::update method  $this - renameHome ( Root );   // in the migration::downgrade method  $this - renameHome ( Home );", 
            "title": "Custom Helper Functions"
        }, 
        {
            "location": "/high-level/", 
            "text": "The situation\n#\n\n\nSo why should you bother creating all those migration files instead of using the backend UI? The issue is that database changes work in a linear fashion, which is hardly \"mergeable\" automatically. If you don't need to merge different changes to your ProcessWire database, you won't need migrations. But chances are high that you do need to do that at some time.\n\n\nFor example migrating changes between a running live system and a development system. It's super easy to push changes to template files or other code from development to the live server. But it's harder when it comes to changes affecting the database a.k.a changes to fields, templates or pages. Consider a scenario where a website is live and your client or other users are creating content online. At the same time you're developing new features for a few weeks or even month on your local machine. When it comes to moving those changes to the live site you need to merge your changes with the changes that happened on the live site.\n\n\nDoing those kind of updates by hand is slow (downtime for the site) and can quite easily lead to errors if something is not 100% correctly transfered. A good amout of discipline in documentation while adding changes locally can improve these issues, but it's still a manual process that does take some time. This is especially apparent if multiple people work on the project and changes come from different people.\n\n\nMigration files take the ambiguity out of this task by moving all needed changes into executable code. This way any database modifications can be reliably recreated on the live system and even be automated. Additionally those migrations can be added to source control \u2013 with all it's benefits \u2013 and are also easy to share to collaborators.\n\n\nEvaluation\n#\n\n\nThe TL;DR points for using the module and migration files.\n\n\nPro:\n\n\n\n\nAutomate changes\n\n\nTrackable by source control\n\n\nSimple to share\n\n\nFast run/rollback to switch between configurations\n\n\n\n\nCons:\n\n\n\n\nMigrations need to be created for each change affecting the db\n\n\nChanges directly via the Admin UI should be avoided\n\n\n\n\nWorkflow\n#\n\n\nSo you get why you need to use migrations, but how does it actually work. In short: Not much different than before. You'll still add fields, change template settings or add \"static\" pages to your installation. Only that you won't do it via the backend UI, but rather by coding those changes with the \nProcessWire API\n. On a high level this will look like that:\n\n\n\n    \n\n        \n\n            \nupdate()\n\n            \ndowngrade()\n\n        \n\n    \n\n  \n\n    \n\n        \nCommon Base\n\n    \n\n  \n\n  \n\n    \nCreate the author field\n\n    \n\n    \n\n    \nDelete the author field\n\n  \n\n  \n\n    \nCreate the blog-post template\n\n    \n\n    \n\n    \nDelete the blog-post template\n\n  \n\n  \n\n    \nInstall SchedulePages module\n\n    \n\n    \n\n    \nDeinstall SchedulePages module\n\n  \n\n  \n\n    \nAdd the blog root page\n\n    \n\n    \n\n    \nRemove the blog-root\n\n  \n\n  \n\n    \n\n        \n\u2026\n\n    \n\n  \n\n\n\n\n\nYou'll probably understand the left part of the table \n but why bother implementing the removal of those changes as well? This is really mainly a workflow improvement as well as a savety net. If you can always rollback your changes you can undo any potentially erroneous migrations at any time and probably much quicker than manually. \n\n\nEven if it's not about errors, you can also use this to improve local work, too. For example in a multi-branch git workflow one might often switch between different branches. This will update the codebase, but not the database state. By rolling back migrations of the current branch, then switching the git branch and migrating all changes for the other branch one can keep file and db modifications in sync.", 
            "title": "How does it work"
        }, 
        {
            "location": "/high-level/#the-situation", 
            "text": "So why should you bother creating all those migration files instead of using the backend UI? The issue is that database changes work in a linear fashion, which is hardly \"mergeable\" automatically. If you don't need to merge different changes to your ProcessWire database, you won't need migrations. But chances are high that you do need to do that at some time.  For example migrating changes between a running live system and a development system. It's super easy to push changes to template files or other code from development to the live server. But it's harder when it comes to changes affecting the database a.k.a changes to fields, templates or pages. Consider a scenario where a website is live and your client or other users are creating content online. At the same time you're developing new features for a few weeks or even month on your local machine. When it comes to moving those changes to the live site you need to merge your changes with the changes that happened on the live site.  Doing those kind of updates by hand is slow (downtime for the site) and can quite easily lead to errors if something is not 100% correctly transfered. A good amout of discipline in documentation while adding changes locally can improve these issues, but it's still a manual process that does take some time. This is especially apparent if multiple people work on the project and changes come from different people.  Migration files take the ambiguity out of this task by moving all needed changes into executable code. This way any database modifications can be reliably recreated on the live system and even be automated. Additionally those migrations can be added to source control \u2013 with all it's benefits \u2013 and are also easy to share to collaborators.", 
            "title": "The situation"
        }, 
        {
            "location": "/high-level/#evaluation", 
            "text": "The TL;DR points for using the module and migration files.  Pro:   Automate changes  Trackable by source control  Simple to share  Fast run/rollback to switch between configurations   Cons:   Migrations need to be created for each change affecting the db  Changes directly via the Admin UI should be avoided", 
            "title": "Evaluation"
        }, 
        {
            "location": "/high-level/#workflow", 
            "text": "So you get why you need to use migrations, but how does it actually work. In short: Not much different than before. You'll still add fields, change template settings or add \"static\" pages to your installation. Only that you won't do it via the backend UI, but rather by coding those changes with the  ProcessWire API . On a high level this will look like that:  \n     \n         \n             update() \n             downgrade() \n         \n     \n   \n     \n         Common Base \n     \n   \n   \n     Create the author field \n     \n     \n     Delete the author field \n   \n   \n     Create the blog-post template \n     \n     \n     Delete the blog-post template \n   \n   \n     Install SchedulePages module \n     \n     \n     Deinstall SchedulePages module \n   \n   \n     Add the blog root page \n     \n     \n     Remove the blog-root \n   \n   \n     \n         \u2026 \n     \n     You'll probably understand the left part of the table   but why bother implementing the removal of those changes as well? This is really mainly a workflow improvement as well as a savety net. If you can always rollback your changes you can undo any potentially erroneous migrations at any time and probably much quicker than manually.   Even if it's not about errors, you can also use this to improve local work, too. For example in a multi-branch git workflow one might often switch between different branches. This will update the codebase, but not the database state. By rolling back migrations of the current branch, then switching the git branch and migrating all changes for the other branch one can keep file and db modifications in sync.", 
            "title": "Workflow"
        }, 
        {
            "location": "/workflow/", 
            "text": "Work in Progress\n\n\n\n\nProject Setup\n#\n\n\nMigrations can be brough into projects of any state with one small requirement. Any enviroment running those migrations does need to start at a common base. For already running projects this will probably be the live server's database, as that's the one that cannot allow for any changes.\n\n\nIf that baseline database is installed then one can start using migration files. Any new environment added to the project can simply start by installing that baseline as well and subsequently running all available migration files. This should result in the minimal setup to run your project. \n\n\nBackups\n#\n\n\n\n\nCreate a backup before running migrations\n\n\n\n\nYour migrations will probably hold lot's of code, which does delete data. This module does not have any security measurements to prevent that. Be sure to test your migrations locally and save a database backup before running them.\n\n\nImmutability of migration files\n#\n\n\n\n\nDo not modify already shared migration files\n\n\n\n\nAs soon as a migration file is shared and possibly run on multiple environments it should never been edited further. If there's an issue with one of them fix it with another migration. The only exception to that rule is if a migration does delete unrecoverable data, but that would obviously need to be communicated to other parties working with those migrations.\n\n\nOrder and Collision\n#\n\n\nFor cases where multiple people work on a site it does happen that two people edit the same thing. If that happens it's best to keep the order of migrations to merge them. Do a rollback to before both of those colliding changes and resolve the issue in the latest of those migrations or even in a new migration. The latter is especially adviseable if you'd need to edit a \nalready shared migration\n.", 
            "title": "Usage"
        }, 
        {
            "location": "/workflow/#project-setup", 
            "text": "Migrations can be brough into projects of any state with one small requirement. Any enviroment running those migrations does need to start at a common base. For already running projects this will probably be the live server's database, as that's the one that cannot allow for any changes.  If that baseline database is installed then one can start using migration files. Any new environment added to the project can simply start by installing that baseline as well and subsequently running all available migration files. This should result in the minimal setup to run your project.", 
            "title": "Project Setup"
        }, 
        {
            "location": "/workflow/#backups", 
            "text": "Create a backup before running migrations   Your migrations will probably hold lot's of code, which does delete data. This module does not have any security measurements to prevent that. Be sure to test your migrations locally and save a database backup before running them.", 
            "title": "Backups"
        }, 
        {
            "location": "/workflow/#immutability-of-migration-files", 
            "text": "Do not modify already shared migration files   As soon as a migration file is shared and possibly run on multiple environments it should never been edited further. If there's an issue with one of them fix it with another migration. The only exception to that rule is if a migration does delete unrecoverable data, but that would obviously need to be communicated to other parties working with those migrations.", 
            "title": "Immutability of migration files"
        }, 
        {
            "location": "/workflow/#order-and-collision", 
            "text": "For cases where multiple people work on a site it does happen that two people edit the same thing. If that happens it's best to keep the order of migrations to merge them. Do a rollback to before both of those colliding changes and resolve the issue in the latest of those migrations or even in a new migration. The latter is especially adviseable if you'd need to edit a  already shared migration .", 
            "title": "Order and Collision"
        }, 
        {
            "location": "/collaboration/", 
            "text": "The same issues, which arrise for indepentent dev and live environment are also true if you're working on a team. But not only do you need to reliably move changes from one environment to another, but actually you need to share changes both ways.\n\n\n\n\nConsidering the scenario of the diagram and its two coworkers, which both made changes to the db structure. Now Jeff want to share his results with Christine. Not very hard if both sit next to each other and Jeff can shortly explain to Christine what needs to change. But what if it's holiday season and they'll not see each other because of overlapping vacations or one of them is a remote or freelance worker and a bit hard to reach in person.\n\n\nMigrations give each coworker a loose framework to apply those changes via coded files, so they can easily be shared to other coworkers by any VCS or other file sharing methods. Nothing will be lost in the communication and everyone can come back a few weeks later and still understand what happended in that specific change. Again applying those patches to the db is no longer a manual task as well. Therefore once a migration is created each coworker can apply them in seconds* to their own installation and spend more time testing for possible incompatibilities.\n\n\nThose migration files also remove the necessity inform coworkers about db changes. It's still a nice thing to do so, but (at least when using git) they'll also see the new migration file(s) in the changelog when merging new features into their own codebase. If they to so they can simply use the CLI tool of the module to run those new migrations and be good to move forward.\n\n\n* There might be longer running migrations, but it's probably not the norm.\n\n\nDifferent DB states\n#\n\n\nWith that approach coworkers each work of of their own database with their own dummydata, but the same underlying template, field \n base-pages setup - because that is all build up only by the migrations on top of a common starting point. I think it's actually a good thing to not share the db, so everyone can work independently and additionally changes might actually be tested in more different situations that way. \n\n\nJust to illustrate that with a small example. Somebody in the team implements a blog and when doing so also adds some dummy posts to his installation. A coworker might not have these posts, runs the migrations and takes a look at the blog out of curiosity. He might notice that the case of an empty blog is not taken care of and possibly even finding some error.", 
            "title": "Collaboration"
        }, 
        {
            "location": "/collaboration/#different-db-states", 
            "text": "With that approach coworkers each work of of their own database with their own dummydata, but the same underlying template, field   base-pages setup - because that is all build up only by the migrations on top of a common starting point. I think it's actually a good thing to not share the db, so everyone can work independently and additionally changes might actually be tested in more different situations that way.   Just to illustrate that with a small example. Somebody in the team implements a blog and when doing so also adds some dummy posts to his installation. A coworker might not have these posts, runs the migrations and takes a look at the blog out of curiosity. He might notice that the case of an empty blog is not taken care of and possibly even finding some error.", 
            "title": "Different DB states"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n#\n\n\nGetting started\n#\n\n\nMigrations are simple small classes, which consist of basically two methods and a static description variable. The two methods are named \nupdate()\n and \ndowngrade()\n and are called respecively when running the migration or rolling it back.\n\n\nThe most basic migration does therefore look something like this:\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_13\n \nextends\n \nMigration\n \n{\n\n\n    \n/**\n\n\n     * Describe what the migration does\n\n\n     */\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nDoesn\nt change anything, just shows messages.\n;\n\n\n    \n/**\n\n\n     * Is executed when the migration is run\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n()\n \n{\n\n        \n$this\n-\nmessage\n(\nRan the update() function!\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Is executed when the migration is rolled back\n\n\n     */\n\n    \npublic\n \nfunction\n \ndowngrade\n()\n \n{\n\n        \n$this\n-\nmessage\n(\nRan the downgrade() function!\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSimple Examples\n#\n\n\nYou might do lot's of different things in those migrations, but I'll just name some examples:\n\n\nChange a field or template setting\n#\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_15\n \nextends\n \nMigration\n \n{\n\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nChange the blog-post template to use it\ns new alternative template file\n;\n\n\n    \npublic\n \nfunction\n \nupdate\n()\n \n{\n\n        \n$t\n \n=\n \n$this\n-\ntemplates\n-\nget\n(\nblog-post\n);\n\n        \n$t\n-\naltFilename\n \n=\n \nblog-post-new.php\n;\n\n        \n$t\n-\nsave\n();\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ndowngrade\n()\n \n{\n\n        \n$t\n \n=\n \n$this\n-\ntemplates\n-\nget\n(\nblog-post\n);\n\n        \n$t\n-\naltFilename\n \n=\n \nblog-post.php\n;\n\n        \n$t\n-\nsave\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAdd some new pages to the installation\n#\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_16\n \nextends\n \nMigration\n \n{\n\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nChange the blog-post template to use it\ns new alternative template file\n;\n\n\n    \npublic\n \nfunction\n \nupdate\n()\n \n{\n\n        \n$this\n-\npages\n-\nadd\n(\nbasic-page\n,\n \n$this\n-\npages\n-\nget\n(\n/\n),\n \nabout\n,\n \narray\n(\n\n            \ntitle\n \n=\n \nAbout me\n,\n\n            \nsummary\n \n=\n \nA short summary about my life?\n,\n\n            \nbody\n \n=\n \n\u2026\n\n        \n));\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ndowngrade\n()\n \n{\n\n        \n$about\n \n=\n \n$this\n-\npages\n-\nget\n(\ntemplate=basic-page, parent=1, name=about\n);\n\n        \nif\n(\n!\n$about\n \ninstanceof\n \nPage\n)\n \nreturn\n;\n\n        \n$about\n-\ndelete\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAdd a field to a tempate, which wasn't needed before\n#\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_16\n \nextends\n \nMigration\n \n{\n\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nChange the blog-post template to use it\ns new alternative template file\n;\n\n\n    \npublic\n \nfunction\n \nupdate\n()\n \n{\n\n        \n$this\n-\ninsertIntoTemplate\n(\nhome\n,\n \ngoogle_analytics\n,\n \ntitle\n);\n\n\n        \n$this\n-\neditInTemplateContext\n(\nhome\n,\n \ngoogle_analytics\n,\n \nfunction\n(\n$f\n){\n\n            \n$f\n-\ncolumnWidth\n \n=\n \n50\n;\n\n        \n});\n\n\n        \n$this\n-\npages\n-\nget\n(\n/\n)\n-\nsetAndSave\n(\ngoogle_analytics\n,\n \nUA-XXXXX-XX\n);\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ndowngrade\n()\n \n{\n\n        \n$t\n \n=\n \n$this\n-\ntemplates\n-\nget\n(\nhome\n);\n\n        \n$t\n-\nfieldgroup\n-\nremove\n(\ngoogle_analytics\n);\n\n        \n$t\n-\nfieldgroup\n-\nsave\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSpecialized Migration Types\n#\n\n\nSpecialized migration types are much simpler to use, because their rollback functionality is much simpler and often tightly coupled to the data needed to run the migration in the first place. Therefore it's enough to supply the information about what to create/add and the deletion will just work as well.\n\n\nField Migration\n#\n\n\nDoes create a field and remove it on rollback.\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_15\n \nextends\n \nFieldMigration\n \n{\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nCreate a new integer field to store the max. number of participants.\n;\n\n\n    \n/**\n\n\n     * Supply the name of the field\n\n\n     */\n\n    \nprotected\n \nfunction\n \ngetFieldName\n(){\n \nreturn\n \nnum_max_participants\n;\n \n}\n\n\n    \n/**\n\n\n     * Supply the type of the field\n\n\n     */\n\n    \nprotected\n \nfunction\n \ngetFieldType\n(){\n \nreturn\n \nFieldtypeInteger\n;\n \n}\n\n\n    \n/**\n\n\n     * Set the field up (it\ns saved automatically)\n\n\n     */\n\n    \nprotected\n \nfunction\n \nfieldSetup\n(\nField\n \n$f\n){\n\n        \n// Base Settings\n\n        \n$f\n-\nlabel\n \n=\n \nMax. Participants\n;\n\n        \n$f\n-\ndescription\n \n=\n \nThe maximum number of participants for this event.\n;\n\n        \n$f\n-\ncollapsed\n \n=\n \nInputfield\n::\ncollapsedNever\n;\n\n\n        \n// Fieldtype Settings\n\n        \n$f\n-\nzeroNotEmpty\n \n=\n \n1\n;\n\n\n        \n// Inputfield Settings\n\n        \n$f\n-\nmin\n \n=\n \n0\n;\n\n        \n$f\n-\ninputType\n \n=\n \nnumber\n;\n\n\n        \n// Add this field after the date field in the event template\n\n        \n$this\n-\ninsertIntoTemplate\n(\nevent\n,\n \n$f\n-\nname\n,\n \ndate\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTemplate Migration\n#\n\n\nDoes create a template and remove it on rollback.\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_17\n \nextends\n \nTemplateMigration\n \n{\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nCreate a new blog-post template\n;\n\n\n    \n/**\n\n\n     * Supply the name of the template\n\n\n     */\n\n    \nprotected\n \nfunction\n \ngetTemplateName\n(){\n \nreturn\n \nblog-post\n;\n \n}\n\n\n    \n/**\n\n\n     * Set the field up (it\ns saved automatically)\n\n\n     */\n\n    \nprotected\n \nfunction\n \ntemplateSetup\n(\nTemplate\n \n$t\n){\n\n        \n$t\n-\nlabel\n \n=\n \nBlog-Post\n;\n\n\n        \n// Global fields are already added\n\n        \n$this\n-\ninsertIntoTemplate\n(\n$t\n,\n \ntitle\n,\n \nbody\n);\n\n        \n$this\n-\ninsertIntoTemplate\n(\n$t\n,\n \nbody\n,\n \ndate_published\n);\n\n        \n$this\n-\ninsertIntoTemplate\n(\n$t\n,\n \ndate_published\n,\n \nauthor\n);\n\n\n        \n// Allow specific urlSegments\n\n        \n$t\n-\nurlSegments\n(\narray\n(\n\n            \ncomments\n,\n\n            \nmedia\n\n        \n));\n\n    \n}\n\n\n}\n\n\n\n\n\n\nModule Migration\n#\n\n\nThis is the simplest migration type. Add the module into the vcs (\n3.0 can also use composer) and install it like this. Will only deinstalled the module on rollback.\n\n\n\n\nDo not remove the module from the vcs before running the migration\nTrying to remove a module without it's files will fail. At best just let ProcessWire remove the files in a additional migration, which could also download it on rollback.\n\n\n\n\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_16\n \nextends\n \nModuleMigration\n \n{\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nInstall LazyCron\n;\n\n    \nprotected\n \nfunction\n \ngetModuleName\n(){\n \nreturn\n \nLazyCron\n;\n \n}\n\n\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#getting-started", 
            "text": "Migrations are simple small classes, which consist of basically two methods and a static description variable. The two methods are named  update()  and  downgrade()  and are called respecively when running the migration or rolling it back.  The most basic migration does therefore look something like this:  ?php  class   Migration_2015_10_21_12_13   extends   Migration   { \n\n     /**       * Describe what the migration does       */ \n     public   static   $description   =   Doesn t change anything, just shows messages. ; \n\n     /**       * Is executed when the migration is run       */ \n     public   function   update ()   { \n         $this - message ( Ran the update() function! ); \n     } \n\n     /**       * Is executed when the migration is rolled back       */ \n     public   function   downgrade ()   { \n         $this - message ( Ran the downgrade() function! ); \n     }  }", 
            "title": "Getting started"
        }, 
        {
            "location": "/examples/#simple-examples", 
            "text": "You might do lot's of different things in those migrations, but I'll just name some examples:", 
            "title": "Simple Examples"
        }, 
        {
            "location": "/examples/#change-a-field-or-template-setting", 
            "text": "?php  class   Migration_2015_10_21_12_15   extends   Migration   { \n\n     public   static   $description   =   Change the blog-post template to use it s new alternative template file ; \n\n     public   function   update ()   { \n         $t   =   $this - templates - get ( blog-post ); \n         $t - altFilename   =   blog-post-new.php ; \n         $t - save (); \n     } \n\n     public   function   downgrade ()   { \n         $t   =   $this - templates - get ( blog-post ); \n         $t - altFilename   =   blog-post.php ; \n         $t - save (); \n     }  }", 
            "title": "Change a field or template setting"
        }, 
        {
            "location": "/examples/#add-some-new-pages-to-the-installation", 
            "text": "?php  class   Migration_2015_10_21_12_16   extends   Migration   { \n\n     public   static   $description   =   Change the blog-post template to use it s new alternative template file ; \n\n     public   function   update ()   { \n         $this - pages - add ( basic-page ,   $this - pages - get ( / ),   about ,   array ( \n             title   =   About me , \n             summary   =   A short summary about my life? , \n             body   =   \u2026 \n         )); \n     } \n\n     public   function   downgrade ()   { \n         $about   =   $this - pages - get ( template=basic-page, parent=1, name=about ); \n         if ( ! $about   instanceof   Page )   return ; \n         $about - delete (); \n     }  }", 
            "title": "Add some new pages to the installation"
        }, 
        {
            "location": "/examples/#add-a-field-to-a-tempate-which-wasnt-needed-before", 
            "text": "?php  class   Migration_2015_10_21_12_16   extends   Migration   { \n\n     public   static   $description   =   Change the blog-post template to use it s new alternative template file ; \n\n     public   function   update ()   { \n         $this - insertIntoTemplate ( home ,   google_analytics ,   title ); \n\n         $this - editInTemplateContext ( home ,   google_analytics ,   function ( $f ){ \n             $f - columnWidth   =   50 ; \n         }); \n\n         $this - pages - get ( / ) - setAndSave ( google_analytics ,   UA-XXXXX-XX ); \n     } \n\n     public   function   downgrade ()   { \n         $t   =   $this - templates - get ( home ); \n         $t - fieldgroup - remove ( google_analytics ); \n         $t - fieldgroup - save (); \n     }  }", 
            "title": "Add a field to a tempate, which wasn't needed before"
        }, 
        {
            "location": "/examples/#specialized-migration-types", 
            "text": "Specialized migration types are much simpler to use, because their rollback functionality is much simpler and often tightly coupled to the data needed to run the migration in the first place. Therefore it's enough to supply the information about what to create/add and the deletion will just work as well.", 
            "title": "Specialized Migration Types"
        }, 
        {
            "location": "/examples/#field-migration", 
            "text": "Does create a field and remove it on rollback.  ?php  class   Migration_2015_10_21_12_15   extends   FieldMigration   { \n     public   static   $description   =   Create a new integer field to store the max. number of participants. ; \n\n     /**       * Supply the name of the field       */ \n     protected   function   getFieldName (){   return   num_max_participants ;   } \n\n     /**       * Supply the type of the field       */ \n     protected   function   getFieldType (){   return   FieldtypeInteger ;   } \n\n     /**       * Set the field up (it s saved automatically)       */ \n     protected   function   fieldSetup ( Field   $f ){ \n         // Base Settings \n         $f - label   =   Max. Participants ; \n         $f - description   =   The maximum number of participants for this event. ; \n         $f - collapsed   =   Inputfield :: collapsedNever ; \n\n         // Fieldtype Settings \n         $f - zeroNotEmpty   =   1 ; \n\n         // Inputfield Settings \n         $f - min   =   0 ; \n         $f - inputType   =   number ; \n\n         // Add this field after the date field in the event template \n         $this - insertIntoTemplate ( event ,   $f - name ,   date ); \n     }  }", 
            "title": "Field Migration"
        }, 
        {
            "location": "/examples/#template-migration", 
            "text": "Does create a template and remove it on rollback.  ?php  class   Migration_2015_10_21_12_17   extends   TemplateMigration   { \n     public   static   $description   =   Create a new blog-post template ; \n\n     /**       * Supply the name of the template       */ \n     protected   function   getTemplateName (){   return   blog-post ;   } \n\n     /**       * Set the field up (it s saved automatically)       */ \n     protected   function   templateSetup ( Template   $t ){ \n         $t - label   =   Blog-Post ; \n\n         // Global fields are already added \n         $this - insertIntoTemplate ( $t ,   title ,   body ); \n         $this - insertIntoTemplate ( $t ,   body ,   date_published ); \n         $this - insertIntoTemplate ( $t ,   date_published ,   author ); \n\n         // Allow specific urlSegments \n         $t - urlSegments ( array ( \n             comments , \n             media \n         )); \n     }  }", 
            "title": "Template Migration"
        }, 
        {
            "location": "/examples/#module-migration", 
            "text": "This is the simplest migration type. Add the module into the vcs ( 3.0 can also use composer) and install it like this. Will only deinstalled the module on rollback.   Do not remove the module from the vcs before running the migration Trying to remove a module without it's files will fail. At best just let ProcessWire remove the files in a additional migration, which could also download it on rollback.    ?php  class   Migration_2015_10_21_12_16   extends   ModuleMigration   { \n     public   static   $description   =   Install LazyCron ; \n     protected   function   getModuleName (){   return   LazyCron ;   }  }", 
            "title": "Module Migration"
        }, 
        {
            "location": "/links/", 
            "text": "Module in the ProcessWire modules directory\n\n\nSupport Topic in the ProcessWire forums\n\n\nSnippets Repository\n\n\nModule's Repository", 
            "title": "Further Links"
        }
    ]
}