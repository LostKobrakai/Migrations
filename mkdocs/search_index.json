{
    "docs": [
        {
            "location": "/", 
            "text": "___       ___       ___       ___       ___       ___       ___\n   /\\__\\     /\\  \\     /\\  \\     /\\  \\     /\\  \\     /\\  \\     /\\  \\\n  /::L_L_   _\\:\\  \\   /::\\  \\   /::\\  \\   /::\\  \\    \\:\\  \\   /::\\  \\\n /:/L:\\__\\ /\\/::\\__\\ /:/\\:\\__\\ /::\\:\\__\\ /::\\:\\__\\   /::\\__\\ /::\\:\\__\\\n \\/_/:/  / \\::/\\/__/ \\:\\:\\/__/ \\;:::/  / \\/\\::/  /  /:/\\/__/ \\:\\:\\/  /\n   /:/  /   \\:\\__\\    \\::/  /   |:\\/__/    /:/  /   \\/__/     \\:\\/  /\n   \\/__/     \\/__/     \\/__/     \\|__|     \\/__/               \\/__/\n\n\n\n\nIntro\n\n\nDescription\n\n\nThere where various threads on the ProcessWire Forums about the topic on how to reasonably handle multiple dev/staging and live environments with ProcessWire and at best handle it as automatically as possible. A git based workflow makes it easy to handle files, but the pain point of migrating db changes has even lead to multiple requests of not handling the template/field setup in the db at all.\n\n\n\n\nThis module does help you to manage migration files, where any changes that affect the database can be stored in php files using just the simple \nProcessWire API\n at your disposal. It's not as nice as using the Admin UI directly, but certainly better than trying to migrate changes manually \u2013  possibly weeks after adding the changes. Also there's always the option to create helper modules, which can export changes made in the Admin UI to something usable in those migration files. I'm using something like that to export template access changes into a json format.\n\n\n\n\nCreate a backup before running migrations!\n\n\nYour migrations will probably hold lot's of code, which does delete data. This module does not have any security measurements to prevent that. Be sure to test your migrations locally and save a database backup before running them.\n\n\n\n\nMigration Types\n\n\nThere are currently four types of migrations:\n\n\n\n\n\n\ndefault (Migration)\n\nDefault migrations are the most free form migrations. There's just a description and two functions \u2013 \nupdate()\n and \ndowngrade()\n. What you're doing in those functions is totally up to you, but it's recommended to try the best to keep changes as reversible as possible. Meaning that running update() and downgrade() once should have as less effect on the installation as possible. The ProcessWire API is available exactly like in modules using the \n$this-\npages\n, \n$this-\nconfig\n, \u2026 syntax.\n\n\n\n\n\n\nFieldMigration\n\n\n\n\nTemplateMigration\n\n\nModuleMigration\n\nThese make your live easier by providing a more declarative way of migrating the creation of Fields/Templates or the installation of modules. All the boilerplate is handled by the base classes these migrations do extend, so you don't need to think about \nupdate()\n and \ndowngrade()\n. You can rather just describe the item you want to handle and the rest is been taken care of.\n\n\n\n\nCLI\n\n\nThe module does include a CLI interface, which does allow the migrations to be run automatically by Continous Integration Systems or deployment scripts or just by yourself if you like the command-line. The script is located in the bin/ directory inside the module's folder. It does however require a composer package to work, which you can simply add by running \ncomposer require league/climate\n in your site directory (or the root directory for pw 3.0). Make sure to require composers autoload.php in your config.php for 2.x installations. \n\n\nThe CLI does have a quite handy help page, which you get by running \nphp migrate -h\n so I'm just adding the important bits of that here:\n\n\n\n> php migrate -h\n\n[\u2026]\n\nUsage: migrate [-h, --help] [-i info, --info info] [-m migrate, --migrate migrate] [-n new, --new new] \n  [-nf newField, --newField newField] [-nm newModule, --newModule newModule] \n  [-nt newTemplate, --newTemplate newTemplate] [-r rollback, --rollback rollback]\n\nOptional Arguments:\n    -m migrate, --migrate migrate\n        Run a specific migration or all new* ones if none given.\n        * From latest migrated to newest.\n    -r rollback, --rollback rollback\n        Undo a specific migration or the latest one if none given.\n    -n new, --new new\n        Bootstrap a new migrations file. Optionally you can already supply a description.\n    -nt newTemplate, --newTemplate newTemplate\n        Bootstrap a new template migrations file. Optionally you can already supply a description.\n    -nm newModule, --newModule newModule\n        Bootstrap a new module migrations file. Optionally you can already supply a description.\n    -nf newField, --newField newField\n        Bootstrap a new field migrations file. Optionally you can already supply a description.\n    -i info, --info info\n        Get detailed info about a migration.\n    -h, --help\n        Show all commands of the cli tool.\n\n\n\n\nTo run the CLI script from the project root simply add a file with the following content to the folder. This way you won't copy anything and it'll update with the module itself like normal.\n\n\n?php\n\n\n// Full or relative path to the module\ns cli\n\n\ninclude_once\n \n__DIR__\n \n.\n \n/site/modules/Migrations/bin/migrate\n;\n\n\n\n\n\n\nHelper Functions\n\n\nThere are already a handful of helper function included in the Migration base class, which tackle things I found to need way to much boilerplate for kinda simple changes. Read the code comments on what each of them does.\n\n\n\n\nThe number of helper functions will probably grow over time.\n\n\n\n\n?php\n\n\n\n/**\n\n\n * This does use @diogo\ns while loop technique to loop over all pages \n\n\n * without getting memory exhaustion. \n\n\n */\n\n\n$this\n-\neachPageUncache\n(\ntemplate=toBeHidden\n,\n \nfunction\n(\n$p\n){\n\n  \n$p\n-\nsetAndSave\n(\nstatus\n,\n \nPage\n::\nstatusHidden\n);\n\n\n});\n \n\n\n\n\n\n?php\n\n\n\n/**\n\n\n * $template, $field, $reference = null, $after = true\n\n\n * The below function reads like this:\n\n\n * In the template \u2026 add the field \u2026 relative to the field \u2026 in the position after/before\n\n\n */\n\n\n$this\n-\ninsertIntoTemplate\n(\nbasic-page\n,\n \nimages\n,\n \nbody\n,\n \nfalse\n);\n \n\n\n\n\n\n?php\n\n\n\n/**\n\n\n * Edit field settings in context of a template\n\n\n */\n\n\n$this\n-\neditInTemplateContext\n(\nbasic-page\n,\n \ntitle\n,\n \nfunction\n(\n$f\n,\n \n$template\n){\n\n  \n$f\n-\nlabel\n \n=\n \nHeadline\n;\n\n\n});\n \n\n\n\n\n\nCustom Helper Functions\n\n\nYou can create your own helper functions by using ProcessWire \nHooks\n. These functions can then be used in your migrations.\n\n\n?php\n\n\n\n// in ready.php\n\n\n$wire\n-\naddHook\n(\nMigration::renameHome\n,\n \nfunction\n(\nHookEvent\n \n$event\n){\n\n    \n$name\n \n=\n \n$event\n-\narguments\n(\n0\n);\n\n    \n$event\n-\nwire\n(\npages\n)\n-\nget\n(\n/\n)\n-\nsetAndSave\n(\ntitle\n,\n \n$name\n);\n\n\n});\n\n\n\n// in the migration::update method\n\n\n$this\n-\nrenameHome\n(\nRoot\n);\n \n\n// in the migration::downgrade method\n\n\n$this\n-\nrenameHome\n(\nHome\n);", 
            "title": "What is it"
        }, 
        {
            "location": "/#intro", 
            "text": "", 
            "title": "Intro"
        }, 
        {
            "location": "/#description", 
            "text": "There where various threads on the ProcessWire Forums about the topic on how to reasonably handle multiple dev/staging and live environments with ProcessWire and at best handle it as automatically as possible. A git based workflow makes it easy to handle files, but the pain point of migrating db changes has even lead to multiple requests of not handling the template/field setup in the db at all.   This module does help you to manage migration files, where any changes that affect the database can be stored in php files using just the simple  ProcessWire API  at your disposal. It's not as nice as using the Admin UI directly, but certainly better than trying to migrate changes manually \u2013  possibly weeks after adding the changes. Also there's always the option to create helper modules, which can export changes made in the Admin UI to something usable in those migration files. I'm using something like that to export template access changes into a json format.   Create a backup before running migrations!  Your migrations will probably hold lot's of code, which does delete data. This module does not have any security measurements to prevent that. Be sure to test your migrations locally and save a database backup before running them.", 
            "title": "Description"
        }, 
        {
            "location": "/#migration-types", 
            "text": "There are currently four types of migrations:    default (Migration) \nDefault migrations are the most free form migrations. There's just a description and two functions \u2013  update()  and  downgrade() . What you're doing in those functions is totally up to you, but it's recommended to try the best to keep changes as reversible as possible. Meaning that running update() and downgrade() once should have as less effect on the installation as possible. The ProcessWire API is available exactly like in modules using the  $this- pages ,  $this- config , \u2026 syntax.    FieldMigration   TemplateMigration  ModuleMigration \nThese make your live easier by providing a more declarative way of migrating the creation of Fields/Templates or the installation of modules. All the boilerplate is handled by the base classes these migrations do extend, so you don't need to think about  update()  and  downgrade() . You can rather just describe the item you want to handle and the rest is been taken care of.", 
            "title": "Migration Types"
        }, 
        {
            "location": "/#cli", 
            "text": "The module does include a CLI interface, which does allow the migrations to be run automatically by Continous Integration Systems or deployment scripts or just by yourself if you like the command-line. The script is located in the bin/ directory inside the module's folder. It does however require a composer package to work, which you can simply add by running  composer require league/climate  in your site directory (or the root directory for pw 3.0). Make sure to require composers autoload.php in your config.php for 2.x installations.   The CLI does have a quite handy help page, which you get by running  php migrate -h  so I'm just adding the important bits of that here:  \n> php migrate -h\n\n[\u2026]\n\nUsage: migrate [-h, --help] [-i info, --info info] [-m migrate, --migrate migrate] [-n new, --new new] \n  [-nf newField, --newField newField] [-nm newModule, --newModule newModule] \n  [-nt newTemplate, --newTemplate newTemplate] [-r rollback, --rollback rollback]\n\nOptional Arguments:\n    -m migrate, --migrate migrate\n        Run a specific migration or all new* ones if none given.\n        * From latest migrated to newest.\n    -r rollback, --rollback rollback\n        Undo a specific migration or the latest one if none given.\n    -n new, --new new\n        Bootstrap a new migrations file. Optionally you can already supply a description.\n    -nt newTemplate, --newTemplate newTemplate\n        Bootstrap a new template migrations file. Optionally you can already supply a description.\n    -nm newModule, --newModule newModule\n        Bootstrap a new module migrations file. Optionally you can already supply a description.\n    -nf newField, --newField newField\n        Bootstrap a new field migrations file. Optionally you can already supply a description.\n    -i info, --info info\n        Get detailed info about a migration.\n    -h, --help\n        Show all commands of the cli tool.  To run the CLI script from the project root simply add a file with the following content to the folder. This way you won't copy anything and it'll update with the module itself like normal.  ?php  // Full or relative path to the module s cli  include_once   __DIR__   .   /site/modules/Migrations/bin/migrate ;", 
            "title": "CLI"
        }, 
        {
            "location": "/#helper-functions", 
            "text": "There are already a handful of helper function included in the Migration base class, which tackle things I found to need way to much boilerplate for kinda simple changes. Read the code comments on what each of them does.   The number of helper functions will probably grow over time.   ?php  /**   * This does use @diogo s while loop technique to loop over all pages    * without getting memory exhaustion.    */  $this - eachPageUncache ( template=toBeHidden ,   function ( $p ){ \n   $p - setAndSave ( status ,   Page :: statusHidden );  });    ?php  /**   * $template, $field, $reference = null, $after = true   * The below function reads like this:   * In the template \u2026 add the field \u2026 relative to the field \u2026 in the position after/before   */  $this - insertIntoTemplate ( basic-page ,   images ,   body ,   false );    ?php  /**   * Edit field settings in context of a template   */  $this - editInTemplateContext ( basic-page ,   title ,   function ( $f ,   $template ){ \n   $f - label   =   Headline ;  });", 
            "title": "Helper Functions"
        }, 
        {
            "location": "/#custom-helper-functions", 
            "text": "You can create your own helper functions by using ProcessWire  Hooks . These functions can then be used in your migrations.  ?php  // in ready.php  $wire - addHook ( Migration::renameHome ,   function ( HookEvent   $event ){ \n     $name   =   $event - arguments ( 0 ); \n     $event - wire ( pages ) - get ( / ) - setAndSave ( title ,   $name );  });  // in the migration::update method  $this - renameHome ( Root );   // in the migration::downgrade method  $this - renameHome ( Home );", 
            "title": "Custom Helper Functions"
        }, 
        {
            "location": "/workflow/", 
            "text": "How does all of this work on a higher level and why do I need this?\n\n\nAbove is the question I need to answer here. So first of all the reason behind all this seemingly laborous migration files.\n\n\nMigrating changes between a running live system and a development system is super easy for changes to files, but hard if it comes to changes affecting the database. Consider a scenario where a site is live (and content is being created there) and you're developing new features for a few weeks or even month. When it comes to moving those changes to the live site you need a way to know which templates need updating and which fields might have been created. \n\n\nDoing those kind of updates by hand is slow (downtime for the site), can quite easily lead to minor or even mayor errors if something is not 100% correctly transfered and it requires a good amout of discipline before that, so all changes are actually catched in development, especially if multiple people work on the project.\n\n\nMigration files take the ambiguity out of the task by moving all those changes into executable code. This way they can be relyably recreated on the live system and even be automated. Additionally those migrations live in source control with all it's benefits and are also easy to share to collaborators.\n\n\nEvaluation (tldr;)\n\n\nPro:\n\n\n\n\nAutomate changes\n\n\nSource control for them\n\n\nSimpler for collaboration\n\n\nFast run/rollback to switch between configurations\n\n\n\n\nCons:\n\n\n\n\nMigrations need to be created for each change affecting the db\n\n\nChanges directly via the Admin UI should be avoided\n\n\n\n\nWorkflow\n\n\nSome of you might know database migrations from frameworks like Laravel or Rails. These specifically change the db schema of the application. That's not what we're doing. We won't edit db tables or otherwise interact with mysql directly as long as there's a ProcessWire API being far more simpler to use. \n\n\nOn a high level migrations will rather look like in this table. \n\n\n\n    \n\n        \n\n            \nupdate()\n\n            \ndowngrade()\n\n        \n\n    \n\n  \n\n    \n\n        \nCommon Base\n\n    \n\n  \n\n  \n\n    \nCreate the author field\n\n    \n\n    \n\n    \nDelete the author field\n\n  \n\n  \n\n    \nCreate the blog-post template\n\n    \n\n    \n\n    \nDelete the blog-post template\n\n  \n\n  \n\n    \nInstall SchedulePages module\n\n    \n\n    \n\n    \nDeinstall SchedulePages module\n\n  \n\n  \n\n    \nAdd the blog root page\n\n    \n\n    \n\n    \nRemove the blog-root\n\n  \n\n  \n\n    \n\n        \n\u2026\n\n    \n\n  \n\n\n\n\n\n[Work in Process]", 
            "title": "How does it work"
        }, 
        {
            "location": "/workflow/#how-does-all-of-this-work-on-a-higher-level-and-why-do-i-need-this", 
            "text": "Above is the question I need to answer here. So first of all the reason behind all this seemingly laborous migration files.  Migrating changes between a running live system and a development system is super easy for changes to files, but hard if it comes to changes affecting the database. Consider a scenario where a site is live (and content is being created there) and you're developing new features for a few weeks or even month. When it comes to moving those changes to the live site you need a way to know which templates need updating and which fields might have been created.   Doing those kind of updates by hand is slow (downtime for the site), can quite easily lead to minor or even mayor errors if something is not 100% correctly transfered and it requires a good amout of discipline before that, so all changes are actually catched in development, especially if multiple people work on the project.  Migration files take the ambiguity out of the task by moving all those changes into executable code. This way they can be relyably recreated on the live system and even be automated. Additionally those migrations live in source control with all it's benefits and are also easy to share to collaborators.", 
            "title": "How does all of this work on a higher level and why do I need this?"
        }, 
        {
            "location": "/workflow/#evaluation-tldr", 
            "text": "Pro:   Automate changes  Source control for them  Simpler for collaboration  Fast run/rollback to switch between configurations   Cons:   Migrations need to be created for each change affecting the db  Changes directly via the Admin UI should be avoided", 
            "title": "Evaluation (tldr;)"
        }, 
        {
            "location": "/workflow/#workflow", 
            "text": "Some of you might know database migrations from frameworks like Laravel or Rails. These specifically change the db schema of the application. That's not what we're doing. We won't edit db tables or otherwise interact with mysql directly as long as there's a ProcessWire API being far more simpler to use.   On a high level migrations will rather look like in this table.   \n     \n         \n             update() \n             downgrade() \n         \n     \n   \n     \n         Common Base \n     \n   \n   \n     Create the author field \n     \n     \n     Delete the author field \n   \n   \n     Create the blog-post template \n     \n     \n     Delete the blog-post template \n   \n   \n     Install SchedulePages module \n     \n     \n     Deinstall SchedulePages module \n   \n   \n     Add the blog root page \n     \n     \n     Remove the blog-root \n   \n   \n     \n         \u2026 \n     \n     [Work in Process]", 
            "title": "Workflow"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nGetting started\n\n\nMigrations are simple small classes, which consist of basically two methods and a static description variable. The two methods are named \nupdate()\n and \ndowngrade()\n and are called respecively when running the migration or rolling it back.\n\n\nThe most basic migration does therefore look something like this:\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_13\n \nextends\n \nMigration\n \n{\n\n\n    \n/**\n\n\n     * Describe what the migration does\n\n\n     */\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nDoesn\nt change anything, just shows messages.\n;\n\n\n    \n/**\n\n\n     * Is executed when the migration is run\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n()\n \n{\n\n        \n$this\n-\nmessage\n(\nRan the update() function!\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Is executed when the migration is rolled back\n\n\n     */\n\n    \npublic\n \nfunction\n \ndowngrade\n()\n \n{\n\n        \n$this\n-\nmessage\n(\nRan the downgrade() function!\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou might do lot's of different things in those migrations, but I'll just name some examples:\n\n\nChange a field or template setting\n\n\n?php\n\n\n\ntest\n\n\n\n\n\n\n\n\nAdd some new pages to the installation\n\n\nAdd a field to a tempate, which wasn't needed before\n\n\n\n\nSpecialized Migration Types\n\n\nSpecialized migration types are much simpler to use, because their rollback functionality is much simpler and often tightly coupled to the data needed to run the migration in the first place. Therefore it's enough to supply the information about what to create/add and the deletion will just work as well.\n\n\nField Migration\n\n\nDoes create a field and remove it on rollback.\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_15\n \nextends\n \nFieldMigration\n \n{\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nCreate a new integer field to store the max. number of participants.\n;\n\n\n    \n/**\n\n\n     * Supply the name of the field\n\n\n     */\n\n    \nprotected\n \nfunction\n \ngetFieldName\n(){\n \nreturn\n \nnum_max_participants\n;\n \n}\n\n\n    \n/**\n\n\n     * Supply the type of the field\n\n\n     */\n\n    \nprotected\n \nfunction\n \ngetFieldType\n(){\n \nreturn\n \nFieldtypeInteger\n;\n \n}\n\n\n    \n/**\n\n\n     * Set the field up (it\ns saved automatically)\n\n\n     */\n\n    \nprotected\n \nfunction\n \nfieldSetup\n(\nField\n \n$f\n){\n\n        \n// Base Settings\n\n        \n$f\n-\nlabel\n \n=\n \nMax. Participants\n;\n\n        \n$f\n-\ndescription\n \n=\n \nThe maximum number of participants for this event.\n;\n\n        \n$f\n-\ncollapsed\n \n=\n \nInputfield\n::\ncollapsedNever\n;\n\n\n        \n// Fieldtype Settings\n\n        \n$f\n-\nzeroNotEmpty\n \n=\n \n1\n;\n\n\n        \n// Inputfield Settings\n\n        \n$f\n-\nmin\n \n=\n \n0\n;\n\n        \n$f\n-\ninputType\n \n=\n \nnumber\n;\n\n\n        \n// Add this field after the date field in the event template\n\n        \n$this\n-\ninsertIntoTemplate\n(\nevent\n,\n \ndate\n,\n \n$f\n-\nname\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTemplate Migration\n\n\nDoes create a template and remove it on rollback.\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_17\n \nextends\n \nTemplateMigration\n \n{\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nCreate a new blog-post template\n;\n\n\n    \n/**\n\n\n     * Supply the name of the template\n\n\n     */\n\n    \nprotected\n \nfunction\n \ngetTemplateName\n(){\n \nreturn\n \nblog-post\n;\n \n}\n\n\n    \n/**\n\n\n     * Set the field up (it\ns saved automatically)\n\n\n     */\n\n    \nprotected\n \nfunction\n \ntemplateSetup\n(\nTemplate\n \n$t\n){\n\n        \n$t\n-\nlabel\n \n=\n \nBlog-Post\n;\n\n\n        \n// Global fields are already added\n\n        \n$this\n-\ninsertIntoTemplate\n(\n$t\n,\n \ntitle\n,\n \nbody\n);\n\n        \n$this\n-\ninsertIntoTemplate\n(\n$t\n,\n \nbody\n,\n \ndate_published\n);\n\n        \n$this\n-\ninsertIntoTemplate\n(\n$t\n,\n \ndate_published\n,\n \nauthor\n);\n\n\n        \n// Allow specific urlSegments\n\n        \n$t\n-\nurlSegments\n(\narray\n(\n\n            \ncomments\n,\n\n            \nmedia\n\n        \n));\n\n    \n}\n\n\n}\n\n\n\n\n\n\nModule Migration\n\n\nThis is the simplest migration type. Add the module into the vcs (\n3.0 can also use composer) and install it like this. Will only deinstalled the module on rollback.\n\n\n\n\nDo not remove the module from the vcs before running the migration\nTrying to remove a module without it's files will fail. At best just let ProcessWire remove the files in a additional migration, which could also download it on rollback.\n\n\n\n\n\n\n?php\n\n\n\nclass\n \nMigration_2015_10_21_12_16\n \nextends\n \nModuleMigration\n \n{\n\n    \npublic\n \nstatic\n \n$description\n \n=\n \nInstall LazyCron\n;\n\n    \nprotected\n \nfunction\n \ngetModuleName\n(){\n \nreturn\n \nLazyCron\n;\n \n}\n\n\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#getting-started", 
            "text": "Migrations are simple small classes, which consist of basically two methods and a static description variable. The two methods are named  update()  and  downgrade()  and are called respecively when running the migration or rolling it back.  The most basic migration does therefore look something like this:  ?php  class   Migration_2015_10_21_12_13   extends   Migration   { \n\n     /**       * Describe what the migration does       */ \n     public   static   $description   =   Doesn t change anything, just shows messages. ; \n\n     /**       * Is executed when the migration is run       */ \n     public   function   update ()   { \n         $this - message ( Ran the update() function! ); \n     } \n\n     /**       * Is executed when the migration is rolled back       */ \n     public   function   downgrade ()   { \n         $this - message ( Ran the downgrade() function! ); \n     }  }   You might do lot's of different things in those migrations, but I'll just name some examples:", 
            "title": "Getting started"
        }, 
        {
            "location": "/examples/#change-a-field-or-template-setting", 
            "text": "?php  test    Add some new pages to the installation  Add a field to a tempate, which wasn't needed before", 
            "title": "Change a field or template setting"
        }, 
        {
            "location": "/examples/#specialized-migration-types", 
            "text": "Specialized migration types are much simpler to use, because their rollback functionality is much simpler and often tightly coupled to the data needed to run the migration in the first place. Therefore it's enough to supply the information about what to create/add and the deletion will just work as well.", 
            "title": "Specialized Migration Types"
        }, 
        {
            "location": "/examples/#field-migration", 
            "text": "Does create a field and remove it on rollback.  ?php  class   Migration_2015_10_21_12_15   extends   FieldMigration   { \n     public   static   $description   =   Create a new integer field to store the max. number of participants. ; \n\n     /**       * Supply the name of the field       */ \n     protected   function   getFieldName (){   return   num_max_participants ;   } \n\n     /**       * Supply the type of the field       */ \n     protected   function   getFieldType (){   return   FieldtypeInteger ;   } \n\n     /**       * Set the field up (it s saved automatically)       */ \n     protected   function   fieldSetup ( Field   $f ){ \n         // Base Settings \n         $f - label   =   Max. Participants ; \n         $f - description   =   The maximum number of participants for this event. ; \n         $f - collapsed   =   Inputfield :: collapsedNever ; \n\n         // Fieldtype Settings \n         $f - zeroNotEmpty   =   1 ; \n\n         // Inputfield Settings \n         $f - min   =   0 ; \n         $f - inputType   =   number ; \n\n         // Add this field after the date field in the event template \n         $this - insertIntoTemplate ( event ,   date ,   $f - name ); \n     }  }", 
            "title": "Field Migration"
        }, 
        {
            "location": "/examples/#template-migration", 
            "text": "Does create a template and remove it on rollback.  ?php  class   Migration_2015_10_21_12_17   extends   TemplateMigration   { \n     public   static   $description   =   Create a new blog-post template ; \n\n     /**       * Supply the name of the template       */ \n     protected   function   getTemplateName (){   return   blog-post ;   } \n\n     /**       * Set the field up (it s saved automatically)       */ \n     protected   function   templateSetup ( Template   $t ){ \n         $t - label   =   Blog-Post ; \n\n         // Global fields are already added \n         $this - insertIntoTemplate ( $t ,   title ,   body ); \n         $this - insertIntoTemplate ( $t ,   body ,   date_published ); \n         $this - insertIntoTemplate ( $t ,   date_published ,   author ); \n\n         // Allow specific urlSegments \n         $t - urlSegments ( array ( \n             comments , \n             media \n         )); \n     }  }", 
            "title": "Template Migration"
        }, 
        {
            "location": "/examples/#module-migration", 
            "text": "This is the simplest migration type. Add the module into the vcs ( 3.0 can also use composer) and install it like this. Will only deinstalled the module on rollback.   Do not remove the module from the vcs before running the migration Trying to remove a module without it's files will fail. At best just let ProcessWire remove the files in a additional migration, which could also download it on rollback.    ?php  class   Migration_2015_10_21_12_16   extends   ModuleMigration   { \n     public   static   $description   =   Install LazyCron ; \n     protected   function   getModuleName (){   return   LazyCron ;   }  }", 
            "title": "Module Migration"
        }, 
        {
            "location": "/links/", 
            "text": "Module in the ProcessWire modules directory\n\n\nSupport Topic in the ProcessWire forums\n\n\nSnippets Repository\n\n\nModule's Repository", 
            "title": "Further Links"
        }
    ]
}